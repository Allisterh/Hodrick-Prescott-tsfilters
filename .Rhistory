INDPRO <- read.csv("//ad.helsinki.fi/home/s/saviviro/Desktop/SGMVARartikkeli/Data/USAdata/INDPRO.csv")
INDPRO <- ts(INDPRO[,2], start=c(1919, 1), frequency=12)
usethis::use_data(INDPRO)
setwd("~/tsfilters")
usethis::use_data(INDPRO)
str(INDPRO)
length(INDPRO)
#'  \cod
hfilter <- function(y, h, p) {
# y = univariate time series indexed as 1,..,T
# h = horizon of the linear projection
# p = number of lags (including zero lag), p >= d
# The first p + h - 1 values are required to obtain the cycle component at time p + h (= first time point of the series)
# Each row X is x_t', x_t=(y_{t},...,y_{t-p+1}, 1), first p values needed for the regressors, the last t+h is for the last observation
X <- t(vapply(p:(length(y) - h), function(t1) c(1, y[t1:(t1 - p + 1)]), numeric(p + 1)))
y_tplush <- y[-(1:(p - 1 + h))] # (p+h, p+h+1, ..., T-1, T)
# The OLS estimate of is then (X'X)^{-1}X'y_tplush - QR factorization is used to reduce numerical error in inverting X'X
qr_X <- qr(X)
beta <- c(backsolve(qr.R(qr_X), crossprod(qr.Q(qr_X), y_tplush))) # qr.solve(X, y_tplush), solve(crossprod(X))%*%crossprod(X, y_tplush)
hat_mat <- tcrossprod(qr.Q(qr_X))
y_hat <- hat_mat%*%y_tplush
list(cycle=y_tplush - y_hat, # starting date is p + h - 1 :th observation of the original series y, for all series returned
trend=y_hat,
total=y_tplush,
beta=beta) # OLS coefficients for the regressors (y_{t},...,y_{t-p+1}, 1)
}
devtools::document()
remove("hfilter")
remove(INDPRO)
devtools::load_all()
data(INDPRO, package=tsfilter)
data(INDPRO, package="tsfilters")
y <- INDPRO
h=24
p=12
tmp <- matrix(1:3)
tmp
as.vector(tmp)
ts(tmp)
ts(as.vector(tmp))
is.matrix(1:3)
h %% 1
1.2 %% 1
4 %% 1
is.matrix(ts(tmp))
as.vector(ts(tmp))
ts.ts(tmp)
is.ts(tmp)
is.ts(ts(tmp))
?ts
y
dates(y)
date(y)
y_start <- start(y)
y_start
y_freq <- frequency(y)
y_freq
y_start <- start(y)
y_freq <- frequency(y)
y <- as.vector(y)
y
# Each row X is x_t', x_t=(y_{t},...,y_{t-p+1}, 1), first p values needed for the regressors,
# the last t+h is for the last observation
X <- t(vapply(p:(length(y) - h), function(t1) c(1, y[t1:(t1 - p + 1)]), numeric(p + 1)))
y_tplush <- y[-(1:(p - 1 + h))] # (p+h, p+h+1, ..., T-1, T)
# The OLS estimate of is then (X'X)^{-1}X'y_tplush - QR factorization is used to reduce numerical
# error in inverting X'X
qr_X <- qr(X)
beta <- c(backsolve(qr.R(qr_X), crossprod(qr.Q(qr_X), y_tplush))) # qr.solve(X, y_tplush), solve(crossprod(X))%*%crossprod(X, y_tplush)
hat_mat <- tcrossprod(qr.Q(qr_X)) # Hat matrix
y_hat <- hat_mat%*%y_tplush
y_hat
# Calculate the new start time for the trend and cyclical components
steps_back <- h + p + 1
steps_back
mod
13 %/% 5
13 %/% 4
y_start
ts(tmp)
start(ts(tmp))
years_back <- steps_back %/% y_freq
years_back
steps_back
minors_back <- steps_back %% y_freq
minors_back
new_start <- y_start - c(years_back, minors_back)
new_start
if(new_start[2] == 1)
1
new_start[2] == 0
new_start <- c(new_start[1] - 1, y_freq - 1)
new_start
data(INDPRO, package="tsfilters")
## Obtain the cyclical component of industrial production
IP <- window(INDPRO, start=c(1951, 8)) # Start time at c(1954, 7), take h + p - 1 months back
IP_filtered <-hfilter(IP, h=24, p=12)
start(IP_filtered$cycle)
start(INDPRO)
start(IP)
devtools::load_all()
devtools::load_all()
IP_filtered <-hfilter(IP, h=24, p=12)
start(IP_filtered$cycle)
devtools::load_all()
IP_filtered <-hfilter(IP, h=24, p=12)
start(IP_filtered$cycle)
start(IP)
y <- IP
# Store properties of the original series
y_start <- start(y)
y_freq <- frequency(y)
y <- as.vector(y)
y_start
devtools::load_all()
IP_filtered <-hfilter(IP, h=24, p=12)
devtools::load_all()
IP_filtered <-hfilter(IP, h=24, p=12)
start(IP_filtered$cycle)
length(IP_filtered$cycle) - length(IP)
h + p -
1
h + p - 1
24 + 12 - 1
usethis::use_test("detrendfilters")
IP_filtered <- hfilter(INDPRO, h=24, p=12)
IP <- window(INDPRO, start=c(1951, 8)) # Start time at c(1954, 7), take h + p - 1 months back
IP_filtered <- hfilter(IP, h=24, p=12)
start(IP_filtered$cycle)
devtools::document()
devtools::test()
x <- IP_filtered
devtools::load_all()
IP_filtered
devtools::document()
devtools::document()
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
paste0("beta", 0:(x$p - 1))
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
str(format_value(x$beta))
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::document()
devtools::document()
devtools::load_all()
plot(IP_filtered)
devtools::load_all()
plot(IP_filtered)
devtools::load_all()
plot(IP_filtered)
devtools::document()
?hfilter
devtools::document()
devtools::document()
?hfilter
devtools::document()
?hfilter
devtools::document()
?hfilter
data(INDPRO, package="tsfilters")
IP_filtered <- hfilter(INDPRO, h=24, p=12)
IP_filtered
plot(IP_filtered)
devtools::document()
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
devtools::load_all()
IP_filtered
IP_filtered
plot(IP_filtered)
devtools::document()
devtools::test()
setwd("~/tsfilters")
usethis::use_readme_rmd()
